## 概览
### 一个列表
1. 树(无向连通图，且没有回路)
2. 二叉树(无向连通图，且没有回路,每个节点最大度数不超过3)
3. 满二叉树
4. 完全二叉树
5. BST(对二叉树进行了父节点、左右子节点的大小约束，左子节点<父节点<右子节点)
6. Treap(A Randomized Binary Search Tree，一种随机化的二叉搜索树，每个节点附加一个随机不重复的优先级值，对于树需要按照节点value满足二叉搜索树，按照节点优先级值需要满足父节点小于子节点的特性，类似小根堆)
7. ScapegoatTree(A Binary Search Tree with Partial Rebuilding，部分重建的二叉搜索树)
8. 平衡二叉搜索树(对二叉查找树进行了节点左右两侧高度差的约束)
9. AVL树(一种平衡二叉搜索树)
10. RBT(一种平衡二叉搜索树)
11. LLRBT(Left-Learning Red Black Trees，RBT改进版)

### 说明
1. 关于实践中二叉树结点的定义，有的是用三个指针，有的使用两个指针，区别在于是否使用第三个指针来指向父节点，这个区别也会导致一些算法的非递归实现需要利用栈来辅助，使用三个指针的结构的情况下，有些递归算法可以直接转成循环性质的代码来实现而不需要模拟递归栈的形式。
2. 堆(heap)是一种完全二叉树，但是Treap不是，虽然Treap具有BST和Heap的一些特性，只是在节点的优先级值方面父节点小于左右两个子节点，但是其排列不一定像完全二叉树那样紧凑而又平衡。
3. 完全二叉树肯定是平衡的(但不一定是具有二叉搜索树的特性)，这里的平衡(高度差绝对值不大于1)不一定是完美平衡(高度差0)
4. 二叉排序树相关的操作：查找、插入、删除，注意删除的实现。
5. 随机二叉排序树，通过对序列进行随机化，然后构建二叉树，避免二叉树极端不平衡的情况。因此各种操作复杂度的衡量只是一个期望值。
6. Treap是一种随机二叉排序树，通过在节点值之外引入优先级值，于是节点值序列和节点值优先级序列决定了唯一的树结构。注意插入和删除的实现。
7. ScapegoatTree通过一个约束来要求平衡性，对于违反约束的部分就要进行暴力重建，暴力重建就是对调整部分先获取有序序列，然后进行中心节点计算并划分，再对左右两侧递归处理，最后达成重建调整的目的。注意插入和删除的实现。
8. ScapegoatTree具有自平衡特性，插入、删除后会进行调整结构以维持其为BST的附加特性，但是严格地说不是平衡二叉树(如果将平衡性定义为任意节点两侧高度差不能超过1)，因为其节点之间的高度差可能大于1，但是其约束使得两侧高度差不会相差太多，具有一定的平衡性，并且在插入或者删除后会调整局部结构以维持这种特定的平衡性。
9. Treap的平衡会利用局部的旋转，通过旋转使得保持二叉搜索性的情况下调整节点位置以符合优先级堆的特点，ScapegoatTree则是局部暴力重建。
10. Treap相关操作时间期望复杂度为logn,ScapegoatTree可以保证最坏复杂度logn。
11. AVL是一种平衡二叉搜索树，为了保持平衡，有左旋、右旋、左旋右旋、右旋左旋四种操作。（AVL取自发明者名字..G. M. Adelson-Velsky和E. M. Landis，1962年的论文...快排是C. A. R. Hoare在1960提出的...)
12. BST、Treap、ScapegoatTree、AVL插入操作比较：后三者都会先进行BST的基本插入操作，添加叶子节点或者更新已有节点值，对于添加了叶子节点的情况，Treap的堆特性可能破坏，通过旋转来修正(L-R两种旋转)，ScaptegoatTree的约束可能被破坏，通过暴力重建来修正，AVL的平衡性可能遭到破坏，通过旋转来修正(L-R-LR-RL四种旋转)。
13. BST、Treap、ScapegoatTree、AVL删除操作比较：BST删除节点操作会先找到此节点，如果有则准备删除此节点。删除操作进行如下判断：如果该节点A没有子节点，则通过对其父节点P处理，直接删除叶子节点即可(P->xx = null)，如果该节点没有右子树(A->right为空)，则通过对其父节点P处理，使用这个唯一的左孩子节点取代被删除节点即可(P->xx = A->left)，上述两种情况可以统一为一种，即被删除节点A没有右节点(即A->right为空)，则P->xx=A->left即可。对于A->right!=null的情况，通过A->right这个孩子节点R,对R的左侧R->left一直寻找到最后一个节点RN,将RN的value赋值给P，然后删除RN节点即可。对上述过程的一个解释是：前一种情况，A没有右分支，因此A->left提上来符合结构，后一种情况，A有右分支，因此可以使用该右分支的最小节点值占据A的位置，这个数值及比A->left大，又比A->right小，然后删除这个叶子节点即可，这是一种操作比较少的调整方式。对于后三种树结构，ScapegoatTree和AVL通过BST的删除节点操作后，会对相关节点进行平衡性判断，根据需要，ScapegoatTree通过暴力重建来修复，AVL通过四种旋转操作来修复，而Treap得删除操作略有不同，首先通过两种旋转操作将A结点逐步移动到末端，然后进行叶子删除操作，每一次移动具体左旋还是右旋需要根据左右子节点优先级值比较结果来决定，这样再最后删除后才能保持其中heap的特性。
14. 红黑树
15. LLRBT(改进的红黑树，标准STL 以及 jdk中应用这个树结构)
16. STL和JDK中，使用的是红黑树，比如TreeMap和TreeSet都是基于改进的红黑树来实现的(LLRBT),这里采用红黑树而非AVL是一个综合性能的考虑。对于检索操作，红黑树没有AVL那么平衡，因此检索效率会稍逊色一点(深度可能更大)；对于插入操作而言，插入带来的失衡两者都能够在常数时间调整，最多两次旋转；对于删除操作而言，红黑树调整可以在三次旋转以内完成，AVL则需要维护删除节点到根节点路径上所有节点的平衡，调整平衡时间复杂度为OlogN，因此，综合考虑，红黑树以牺牲一定的平衡性换来更高的删除效率，在综合表现上会好一些，当然如果使用场景是查询居多，删除插入很少，则AVL是一个比较好的选择。

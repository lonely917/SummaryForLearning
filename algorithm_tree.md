## 概览

### 一个列表

1. 树(无向连通图，且没有回路)
2. 二叉树(无向连通图，且没有回路,每个节点最大度数不超过3)
3. 满二叉树
4. 完全二叉树
5. BST(对二叉树进行了父节点、左右子节点的大小约束，左子节点<父节点<右子节点)
6. Treap(A Randomized Binary Search Tree，一种随机化的二叉搜索树，每个节点附加一个随机不重复的优先级值，对于树需要按照节点value满足二叉搜索树，按照节点优先级值需要满足父节点小于子节点的特性，类似小根堆)
7. ScapegoatTree(A Binary Search Tree with Partial Rebuilding，部分重建的二叉搜索树)
8. 平衡二叉搜索树(对二叉查找树进行了节点左右两侧高度差的约束)
9. AVL树(一种平衡二叉搜索树)
10. RBT(一种平衡二叉搜索树)
11. LLRBT(Left-Learning Red Black Trees，RBT改进版)

### 说明
1. 关于实践中二叉树结点的定义，有的是用三个指针，有的使用两个指针，区别在于是否使用第三个指针来指向父节点，这个区别也会导致一些算法的非递归实现需要利用栈来辅助，使用三个指针的结构的情况下，有些递归算法可以直接转成循环性质的代码来实现而不需要模拟递归栈的形式。
2. 堆(heap)是一种完全二叉树，但是Treap不是，虽然Treap具有BST和Heap的一些特性，只是在节点的优先级值方面父节点小于左右两个子节点，但是其排列不一定像完全二叉树那样紧凑而又平衡。
3. 完全二叉树肯定是平衡的(但不一定是具有二叉搜索树的特性)，这里的平衡(高度差绝对值不大于1)不一定是完美平衡(高度差0)
4. 二叉排序树相关的操作：查找、插入、删除，注意删除的实现。
5. 随机二叉排序树，通过对序列进行随机化，然后构建二叉树，避免二叉树极端不平衡的情况。因此各种操作复杂度的衡量只是一个期望值。
6. Treap是一种随机二叉排序树，通过在节点值之外引入优先级值，于是节点值序列和节点值优先级序列决定了唯一的树结构。注意插入和删除的实现。
7. ScapegoatTree通过一个约束来要求平衡性，对于违反约束的部分就要进行暴力重建，暴力重建就是对调整部分先获取有序序列，然后进行中心节点计算并划分，再对左右两侧递归处理，最后达成重建调整的目的。注意插入和删除的实现。
8. ScapegoatTree具有自平衡特性，插入、删除后会进行调整结构以维持其为BST的附加特性，但是严格地说不是平衡二叉树(如果将平衡性定义为任意节点两侧高度差不能超过1)，因为其节点之间的高度差可能大于1，但是其约束使得两侧高度差不会相差太多，具有一定的平衡性，并且在插入或者删除后会调整局部结构以维持这种特定的平衡性。
9. Treap的平衡会利用局部的旋转，通过旋转使得保持二叉搜索性的情况下调整节点位置以符合优先级堆的特点，ScapegoatTree则是局部暴力重建。
10. Treap相关操作时间期望复杂度为logn,ScapegoatTree可以保证最坏复杂度logn。
11. AVL是一种平衡二叉搜索树，为了保持平衡，有左旋、右旋、左旋右旋、右旋左旋四种操作。（AVL取自发明者名字..G. M. Adelson-Velsky和E. M. Landis，1962年的论文...快排是C. A. R. Hoare在1960提出的...)
12. BST、Treap、ScapegoatTree、AVL插入操作比较：后三者都会先进行BST的基本插入操作，添加叶子节点或者更新已有节点值，对于添加了叶子节点的情况，Treap的堆特性可能破坏，通过旋转来修正(L-R两种旋转)，ScaptegoatTree的约束可能被破坏，通过暴力重建来修正，AVL的平衡性可能遭到破坏，通过旋转来修正(L-R-LR-RL四种旋转)。
13. BST、Treap、ScapegoatTree、AVL删除操作比较：BST删除节点操作会先找到此节点，如果有则准备删除此节点。删除操作进行如下判断：如果该节点A没有子节点，则通过对其父节点P处理，直接删除叶子节点即可(P->xx = null)，如果该节点没有右子树(A->right为空)，则通过对其父节点P处理，使用这个唯一的左孩子节点取代被删除节点即可(P->xx = A->left)，上述两种情况可以统一为一种，即被删除节点A没有右节点(即A->right为空)，则P->xx=A->left即可。对于A->right!=null的情况，通过A->right这个孩子节点R,对R的左侧R->left一直寻找到最后一个节点RN,将RN的value赋值给P，然后删除RN节点即可。对上述过程的一个解释是：前一种情况，A没有右分支，因此A->left提上来符合结构，后一种情况，A有右分支，因此可以使用该右分支的最小节点值占据A的位置，这个数值及比A->left大，又比A->right小，然后删除这个叶子节点即可，这是一种操作比较少的调整方式。对于后三种树结构，ScapegoatTree和AVL通过BST的删除节点操作后，会对相关节点进行平衡性判断，根据需要，ScapegoatTree通过暴力重建来修复，AVL通过四种旋转操作来修复，而Treap得删除操作略有不同，首先通过两种旋转操作将A结点逐步移动到末端，然后进行叶子删除操作，每一次移动具体左旋还是右旋需要根据左右子节点优先级值比较结果来决定，这样再最后删除后才能保持其中heap的特性。
14. 红黑树
15. LLRBT(改进的红黑树，标准STL 以及 jdk中应用这个树结构)
16. STL和JDK中，使用的是红黑树，比如TreeMap和TreeSet都是基于改进的红黑树来实现的(LLRBT),这里采用红黑树而非AVL是一个综合性能的考虑。对于检索操作，红黑树没有AVL那么平衡，因此检索效率会稍逊色一点(深度可能更大)；对于插入操作而言，插入带来的失衡两者都能够在常数时间调整，最多两次旋转；对于删除操作而言，红黑树的平衡调整可以在三次旋转以内完成，AVL则需要维护删除节点到根节点路径上所有节点的平衡，调整平衡时间复杂度为OlogN，因此，综合考虑，红黑树以牺牲一定的平衡性换来更高的删除效率，在综合表现上会好一些，当然如果使用场景是查询居多，删除插入很少，则AVL是一个比较好的选择。

## 二叉树

### 存储实现
1. 使用数组存储，首先要将树补充完整，通过添加空节点，成为高度为h的完全二叉树，然后按照层次遍历的顺序进行存储，对于高度为h的二叉树需要2^h-1空间，如果不是完全二叉树则会额外耗费不少空间。堆常用这种存储来实现，因为堆是一种完全二叉树。如果从0进行编号，则父节点i对应子节点编号(如果有子节点的话)为2*i+1、2*i+2，子节点i对应父节点编号(i-1)/2向下取整，如果对应位置节点值为空或者不在长度范围内，则说明对应节点为空。

2. 双指针链式存储，节点值+左右孩子指针。省空间，但不能随机访问。
3. 三指针链式存储，节点值+左右孩子指针+父亲指针。能够更好地实现节点间的访问和遍历。

### 遍历(Traversal)

1. 深度优先DFS和广度优先BFS的概念来自于图的遍历，树也是一种特殊的图，因此可以使用这两种方式。
2. 层次遍历就是BFS的一种，对于数组存储的结构，其顺序就是层次遍历的顺序(会含有额外补充的空节点)，使用链式存储的需要借助队列来实现层次遍历。
3. 前、中、后序三种遍历都属于深度优先，通过递归可以比较方便地实现遍历算法。
4. 双指针链式存储的情况下三种遍历方式的非递归实现。通过栈模拟可以实现基于栈的非递归实现算法。
5. 如果使用的是三指针链式存储表示二叉树，三种遍历都可以迭代地完成，即不需要辅助栈结构的情况下实现非递归的遍历算法。一种理解：递归或者栈模拟进行非递归，都需要O(h)的辅助空间，h为树深度，但是三指针可以不用栈模拟，意味着省去了这部分空间，可是在数据存储上会占用更多的空间，多了O(n)级别的指针空间。
6. 双指针链式存储实现O(1)辅助空间的非递归遍历，可以借助线索二叉树的思路，利用树结构中的指向为null的指针，通过建立索引和删除索引，实现在不改变树结构的情况下，在O(1)辅助空间条件下实现前中后序的遍历(没有辅助栈)。   

### 关联数组
关联数组、Map键值对、Dictionary字典，都是一个概念，与之对应的是索引数组(通过数字编号进行定位)，关联数组则可以通过key值定位，本质就是键值对的集合。Java中关联数组的实现有HashTable、HashMap等，这些是基于散列表来实现，如果集合内元素有一定有序性，比如LinkedHashMap(保持插入顺序)和TreeMap(通过键值排序)，则使用红黑树来实现。
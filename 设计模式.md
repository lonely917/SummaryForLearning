<!-- TOC -->

- [设计模式](#设计模式)
    - [OO设计准则](#oo设计准则)
    - [创建型模式](#创建型模式)
        - [单例模式](#单例模式)
            - [java单例模式若干场景](#java单例模式若干场景)
        - [原型模式](#原型模式)
        - [工厂方法模式](#工厂方法模式)
        - [抽象工厂](#抽象工厂)
        - [建造者模式](#建造者模式)
    - [结构型模式(类结构型，对象结构型)](#结构型模式类结构型对象结构型)
        - [适配器模式](#适配器模式)
        - [代理模式](#代理模式)
        - [桥接模式](#桥接模式)
        - [装饰模式](#装饰模式)
        - [外观模式](#外观模式)
        - [享元模式](#享元模式)
        - [组合模式](#组合模式)
    - [行为型模式(类行为和对象行为)](#行为型模式类行为和对象行为)
        - [模板方法(类行为)](#模板方法类行为)
        - [解释器模式(类行为)](#解释器模式类行为)
        - [策略模式](#策略模式)
        - [命令模式](#命令模式)
        - [职责链模式](#职责链模式)
        - [状态模式](#状态模式)
        - [观察者模式](#观察者模式)
        - [中介者模式](#中介者模式)
        - [迭代器模式](#迭代器模式)
        - [访问者模式](#访问者模式)
        - [备忘录](#备忘录)
- [UML类图](#uml类图)
    - [uml类图中的各种关系](#uml类图中的各种关系)

<!-- /TOC -->
## 设计模式
### OO设计准则
1. 开闭准则[对扩展开放，对修改封闭，提高复用性和可维护性，基本准则，也是其他准则的目标。eg,windows桌面主题]
2. 里氏替换准则[强调基类和子类的关系，子类尽量不要重写父类方法，避免对基类已有行为的破环，可以进行扩展。eg,几维鸟不是鸟，飞行时间计算]
3. 依赖倒置原则[高层模块不应依赖底层模块，两者依赖彼此抽象；抽象不应依赖细节，细节依赖抽象。即面向接口编程。比如不要直接从具体类派生，应该有顶层抽象类或者接口，传参或者声明使用基类等，继承尽量遵循里氏替换。]
4. 单一职责原则[SRP,一个类应尽量只有一个引起他变化的原因，即尽量赋予少的职责，否则就应进行拆分；缺点是会削弱一个类的功能以及带来代码的冗余；优点：降低类的复杂度，有利于解耦提高内聚性，细粒度控制]
5. 接口隔离[ISP,客户端不应该被迫依赖于它不使用的方法,也是为了解耦提高内聚。SRP作用于类，ISP作用于接口。接口分类，而不要一个庞大的接口。]
6. 迪米特原则[LOD]/最小知识原则[LKP][只与你的直接朋友交谈，无须通信的实体不应发生直接调用，通过第三方来转发。可以降低耦合度，但会产生大量中介类。]
7. 合成复用原则/组合聚合原则[优先使用组合聚合而后继承，继承要遵循LSP里氏替换]

```
这 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。
```

### 创建型模式

#### 单例模式

    (懒加载&饿汉模式,多线程考虑,扩展-有限单例模式)

##### java单例模式若干场景
1. 普通饿汉模式(static变量初始化/static变量+初始化代码块)
2. 普通懒加载(线程安全不保证)
3. 普通同步懒加载(过度加锁影响效率)
4. 双重检测的同步懒加载(结合volatile修饰实现1.5之后线程安全)
5. 静态内部类懒加载(holder模式，线程安全)
6. 枚举类型使用(利用holder模式，实现懒加载)

完备的单例还应该考虑反射以及序列化带来的问题，反射可以修改构造函数的访问级别，进而可能使用构造函数创建对象；反序列化也可以创建新对象违反单例的框架设置。

针对前者，可以使用修改构造函数，除了改为private外，方法体内对static变量进行判断，如果已经有实例化对象，则抛出异常，这样在已有单例的情况下就不能调用构造函数了，但是此种情况只能适用饿汉模式，相当于类初始化的过程中就把单例初始化了，后续反射就会出现异常，如果是懒加载模式，那么在触发懒加载之前，还没有单例生成，这是反射依然可以得到新生对象。

针对后者，可以通过控制反序列化的细节，通过重写readResolve方法，直接返回实例变量即可。注意，在这种场景下，序列化已经失去意义，因为反序列化并没有使用数据内的信息，因此最安全的场景是将非静态属性都设置为transient，这样序列化就不会存储有效信息，避免了反序列化时可能发生的违背安全性的场景，即如若仅仅重写readResolve还是有一定风险，在攻击者拿到比较高的操作权限的情况下，有一些非常规手段可以生成新的对象。

#### 原型模式

    (clone，通过对一个对象进行复制生成新个体，java的cloneable接口，注意深拷贝&浅拷贝)

#### 工厂方法模式

    (定义一个创建产品的接口，子类决定具体创建行为，具体工厂对应一个产品、通过配置文件以及反射来遵循开闭原则)

#### 抽象工厂

    (定义一个创建产品簇的接口，子类决定具体创建行为，具体工厂对应一个产品簇、通过配置文件以及反射来遵循开闭原则)

#### 建造者模式

    构建过程拆分，按照一定步骤执行，最后创建实例。

### 结构型模式(类结构型，对象结构型)

#### 适配器模式

    (同时属于类结构型和对象结构型，其余均为对象结构型)
    通过适配器，将新类接口适配到已有的接口中。单向适配和双向适配。

#### 代理模式

    代理的思想，通过一个代理去调用具体对象，可以对调用进行外部统计和控制，也可对内部操作进行一定程度的隐藏。具体又有静态代理和动态代理(java中的proxy和invocationhandler的使用)。

#### 桥接模式

    抽象和实现分离，结构根据维度进行划分，使用组合替代继承，避免子类的过度膨胀。

#### 装饰模式

    对一个类添加职责，使用组合来创建包装对象(包裹一个真实对象)，装饰类不改变原先功能实现(super调用)的基础上并添加附加职责。

#### 外观模式

    通过外观类来对若干个子系统进行统一协调调用，迪米特原则的体现。

#### 享元模式

    通过共享降低对象数量，需要区分内部状态和外部状态，寻找哪些是可共享的部分。

#### 组合模式

    用于整体和部分的结构组织。树叶和树枝的概念，分透明方式和安全方式两种。透明方式在行为接口中包括基本操作以及树枝的对叶节点的管理操作，因此树叶也会具有树枝的管理行为实现，可能是空或者抛出异常，因此不安全。安全方式下顶层接口只包含基本操作行为，管理操作则为树枝的附加操作。

### 行为型模式(类行为和对象行为)

#### 模板方法(类行为)

    基类制定一个执行框架，框架里涉及多个抽象方法，子类具体实现这些抽象方法。

#### 解释器模式(类行为)

    解释的概念，文法相关。解释器。java中的数学公式解析器Expression4J、MESP(Math Expression String Parser) 和 Jep 。

#### 策略模式

    定义一个公共接口，将不同的算法(策略)设计成具体的策略类，替代多重条件判断，隐藏实现细节。

#### 命令模式

    典型地，包含具体命令(有抽象命令接口)、命令接收者，命令调用者，通过命令调用者执行一系列设定的命令。结合备忘录模式可以实现可撤销的。

#### 职责链模式

    对请求和处理进行解耦，客户创建处理链，一个请求指定下一个处理者，处理者判断处理并传递给后继处理者。

#### 状态模式

    基于状态变换，每次handle后会变更状态，因此会根据状态设计很多状态类。

#### 观察者模式

    事件源和接收者；被观察者和观察者；发布者和订阅者；
    建立目标和观察者之间的一种触发机制。
    (java中observable&observal接口)

#### 中介者模式

    将复杂网状结构改为星型，中介者实现消息的转发。

#### 迭代器模式

    将聚合类的遍历交给一个抽象类，抽象类可以派生不同的遍历子类。封装性。

#### 访问者模式

    适用于对象结构相对稳定，但是操作经常变化的情况，操作设计成不同的访问者。

#### 备忘录

    通过建立备忘录来进行快照和复原操作。


```
某些设计模式的简单形式可能会对开闭原则违背，比如简单工厂、外观模式等，都是新增子类会对工厂类或者外观类提出改变，这时利用抽象类来解决这一问题，实现通过配置文件来扩展程序的便捷。新增子类以及工厂类、外观类后，通过配置文件的修改，来实现同样代码下实例化对象的不同类型。这也是抽象类的一个很广法的应用。
```

## UML类图
### uml类图中的各种关系
- 依赖
- 关联{一般关联；聚合；组合}
- 泛化
- 实现

`联系程度:依赖<关联<聚合<组合<泛化=实现`

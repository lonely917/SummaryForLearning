## 排序算法

1. 冒泡排序
2. 选择排序
3. 插入排序
4. 希尔排序
5. 快速排序
6. 归并排序
7. 桶排序
8. 基数排序


## 算法分析一览表  

排序|时间复杂度|额外空间|是否稳定
-|-|-|-
冒泡|O(n^2) |O(1)|稳定
选择|O(n^2) |O(1)|不稳定
插入|O(n^2) |O(1)|稳定
希尔|O(n^1.5)|O(1)|不稳定
快排|O(nlogn)|O(logn)|不稳定
归并|O(nlogn)|O(n)|稳定
桶排序|-|-|-
基数|O(n)|-|稳定

## 冒泡排序

1. 常见的情况，每次遍历对相邻逆序进行交换，遍历一遍后尾部最大数值。第二次遍历得到次大值位于倒数第二个位置。经过N次遍历数列有序。总结来说就是两层循环，内层循环用于不断比较交换得到循环内最大(小)值。
(实际的实现也可以从后向前进行遍历，每次得到一个头部的最小值，这样的顺序和其他算法更容易近似对比)
2. 优化之1，如果内层遍历没有发生交换，则已经有序，可以提前结束外层循环，直接得到结果。
3. 优化之2，内层循环遍历的时候记录每次发生交换的最后位置，下次内层循环的时候到这个位置即可终结本次循环，即内部循环提前终结。

## 选择排序
1. 每次从待排序序列中找到一个最小值，交换到待排序序列的首部，相对于冒泡排序这里内部循环只进行一次交换。经过N次(N-1次)外层循环后，整个序列有序。这个交换的过程会导致这个算法是不稳定的。一般这个序列如果使用数组的存储，那么我们进行最值和待排序首部的交换可能导致相同大小元素的位序错乱，(比如 5-5-4进行变换后变成4-5-5，两个5的顺序发生了颠倒)。选择排序的稳定性是一个有争议的地方，数据的存储方式(数组、链表)以及是否进行一定的变种(可能有额外的开销)，都可能实现所谓的稳定的选择排序。

## 插入排序
每次将待排序序列中的一个元素插入到有序序列中，外层循环进行n次插入，内层循环进行插入位置的寻找以及已排序元素的移动。

## 希尔排序
1. 增量递减插入排序，插入排序可以看作增量为1的希尔排序。
2. `希尔排序的编码实现以及复杂度分析` O(n^1.5)来历?

## 快速排序
快排的思路是利用基准值对序列进行划分，使得基准值归位，左侧都小于等于基准，右侧大于等于基准。可以利用递归的思路对左右两侧序列继续进行快速排序。递归的终点是只有一个元素的序列，自然就是有序的。基准值的选取比较重要，可以选择最左侧、左右侧、或者中值。比如对于一个递增序列，选取最左侧为基准值将导致划分严重不均，算法时间复杂度退化为O(n^2)。为了避免这种情况可以选择中值或者随机一个位置作为基准值(实际实现的时候随机性的计算可能会影响性能，对于基准值的选择也有不同的方式),因此算法的平均时间复杂度为O(nlogn)，但理论上仍有可能发生最差的情况。排序的实际实现中会根据问题规模结合不同的排序算法，比如快排当序列划分到比较小规模的时候可以采用插入排序进行操作。注意快排是不稳定的，其中会进行两侧数据的交换，这一点会导致不稳定。

1. 单路快排
2. 双路快排
3. 三路快排
4. 双基准快排
5. 简单快排的递归实现(栈模拟递归过程)

(参考jdk-Arrays.sort以及stl排序算法)

## 归并排序
归并排序是把序列从中间分成两部分，左右两侧分别进行归并排序，然后合并左右两侧有序数列，也是一个递归的过程。归并排序是稳定的，接近`基于比较的排序的时间下限O(nlogn)`,最坏情况也是如此，其中merge的过程需要额外的空间辅助O(n)，递归深度O(logn)，因此空间复杂度O(n)+O(logn)=O(n)，时间复杂度为O(nlogn),因为进行logn次merge,每层深度对应的merge序列数目之和也为n。

归并较快排而言时间复杂度比较稳定，不会因序列内容而退化，同时是一个稳定排序算法，但是空间复杂度更高。

(参考jdk-Arrays.sort以及stl排序算法)
## 堆排序